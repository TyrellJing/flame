# 索引的实现原理

索引的底层主要有三种实现，分别是BTree和B+Tree索引，哈希索引和全文索引。MySQL支持多种存储引擎，不同的存储引擎对索引的支持各不相同。

## 哈希索引

哈希索引使用索引列的值计算哈希值，将数据存储在哈希值映射的物理位置，使用散列算法访问速度非常快，但是哈希索引不支持范围查找和排序功能。

## 全文索引

对于char，varchar和text类型字段，如果匹配中间的某些字符需要使用全文索引，在生成FULLTEXT索引时，会为文本生成一份单词的清单，在索引时及根据这个单词的清单来索引。

针对较大的数据生成全文索引非常消耗时间和空间。

## BTree和B+Tree索引

- B树是一棵多路平衡查找树，B树和B+树由简单的二叉树演变而来。一个m阶B树的定义如下：

    - 每个节点最多有m-1个关键字(可以存键值对)。

    - 根节点最少可以有1个关键字。

    - 非根节点至少有m/2个关键字。

    - 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。

    - 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度相同。

    - 每个节点都存有索引和数据，也就是对应的key和value。

  ![](../assets/39a6b440ba8f6a8c4d180c53b515dd8c_6.png)

- B+树和B树一样也是多路平衡查找树，一个m阶B+树的定义如下：

    - 每个节点最多有m-1个关键字(非叶子节点只存索引)

    - 根节点最少可以有1个关键字。

    - 非根节点至少有m/2个关键字。

    - B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。

    - 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。

    - 每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。

    - 父节点存有右孩子的第一个元素的索引。

    ![](../assets/19dd3d1e5ad169e8c1bd8fd2dbc67326_6.png)

B+树相比B树的优点：

- 非叶子节点不存储数据只存储指针，可以存储比较多的指针，树的高度更低，需要的IO次数少，查询效率更高。

- 非叶子节点不存储数据，所有数据都要查询到叶子节点，所有叶子节点的高度相同，所有数据的查询速度一样，查询速度更稳定。

- 叶子节点通过指针来连接，区间查询效率更高，而B树需要在叶子节点中移动。

## 聚集索引

InnoDB存储引擎表是索引组织表，即表中数据是按主键顺序存放。聚集索引(clustered index)就是按照每张表的主键构造一棵B+树，同时叶子节点存放的是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。聚集索引的这个特性决定了索引组织表中的数据也是索引的一部分。由于B+树的叶子节点通过指针相连，聚集索引能够特别快地访问针对范围值的查询。

## 辅助索引

辅助索引(secondary index)也称非聚集索引，叶子节点并不包含行记录的全部数据。叶子节点除了包含值以外，每个叶子节点中的索引行中还包含了一个书签(bookmark)。该书签用于告诉InnoDB存储引擎哪里可以找到索引行对应的数据。由于InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。

## 覆盖索引

InnoDB存储引擎支持覆盖索引(covering index)也叫索引覆盖，即辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，故大小要远小于聚集索引，因此可以减少大量IO操作。

## 索引的使用策略

什么时候要使用索引？

- 主键自动建立唯一索引。

- 经常作为查询条件在where语句中出现，考虑建立索引。

- 经常在排序order by或分组group by语句中出现，考虑建立索引。

- 查询与其他表关联的字段，外键关系建立索引。

- 高并发条件下倾向建立组合索引。

- 用于聚合函数的列考虑建立索引。

什么时候不要使用索引？

- 经常增删改的列不要建立索引。

- 有大量重复的列不要建立索引。

- 表记录太少不要建立索引

## 索引失效的情况

- 在组合索引中不能有列值为null的情况，如果有，那么这一列对组合索引就是无效的。

- 在使用like语句时，只有在模糊匹配的第一个字符不是通配符的情况下才能使用索引。

- 在使用正则表达式时，只有在搜索模板的第一个字符不是通配符的情况下才能使用索引。

- 在索引的列上使用表达式或者函数会导致索引失效。例如：select * from users where YEAR(adddate)<2007，将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成：select * from users where adddate<’2007-01-01′。

- 在查询条件中使用不等于，包括<符号、>符号和！=会导致索引失效。如果对主键索引使用！=则不会使索引失效，如果对主键索引或者整数类型的索引使用<符号或者>符号不会使索引失效

- 在查询条件中使用IS NULL或者IS NOT NULL会导致索引失效。

- 字符串不加单引号会导致索引失效。更准确的说是类型不一致会导致失效。比如字段email是字符串类型的，使用WHERE email=99999 则会导致失败，应该改为WHERE email='99999'。

- 在查询条件中使用OR连接多个条件会导致索引失效，除非OR链接的每个条件都加上索引，这时应该改为两次查询，然后用UNION ALL连接起来。

- 如果排序的字段使用了索引，那么select的字段也要是索引字段，否则索引失效。特别的是如果排序的是主键索引则select * 也不会导致索引失效。

- 尽量不要包括多列排序，如果一定要，最好为这队列构建组合索引。

## 索引优化

1. 最左前缀

索引的最左前缀和和B+Tree中的“最左前缀原理”有关，举例来说就是如果设置了组合索引<col1,col2,col3>那么以下3中情况可以使用索引：col1，<col1,col2>，<col1,col2,col3>，其它的列，比如<col2,col3>，<col1,col3>，col2，col3等等都是不能使用索引的。

根据最左前缀原则，我们一般把排序分组频率最高的列放在最左边，以此类推。

2. 带索引的模糊查询优化

在上面已经提到，使用LIKE进行模糊查询的时候，'%aaa%'不会使用索引，也就是索引会失效。如果是这种情况，只能使用全文索引来进行优化。

```sql
SELECT * FROM tablename MATCH(index_colum) ANGAINST(‘word’);
```

3. 使用短索引

对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。


