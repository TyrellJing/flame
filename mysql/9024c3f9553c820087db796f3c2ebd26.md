# 锁的机制

锁是计算机协调多进程或线程访问某一资源的机制。在数据库中，除了计算资源的争抢，数据也是一种供多用户共享的资源。

- 优点：可以保证数据的一致性，有效性。

- 缺点：锁的各种操作消耗系统资源，锁冲突影响并发性。

## 锁的类型

### 表锁

默认使用表锁的存储引擎：MyISAM

- 读锁(read lock)或共享锁(shared lock)：针对一份数据，多个读操作可以同时进行而不会互相影响(select)。

- 写锁(write lock)或排他锁(exclusive lock)：当写操作没完成之前，会阻塞其他读或者写操作(update,insert,delete)。

读锁会阻塞写操作，不会阻塞读操作，写锁会阻塞读操作和写操作。MyISAM的读写锁调度是写优先，加写锁后其他线程不能做任何操作，大量的更新和查询很难得到锁，因此MyISAM不适合读多写少的业务场景。

特点：对整张表加锁，开销小，加锁快，无死锁，锁粒度大，锁冲突概率高，并发性低。

### 行锁

默认使用行锁的存储引擎：InnoDB

- 共享锁(S)或读锁：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。

- 排他锁(X)或写锁：允许获得排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。

- 意向排他锁(IX)：一个事务给一个数据行加排他锁时，必须先获得该表的IX锁。

- 意向共享锁(IS)：一个事务给一个数据行加共享锁时，必须先获得该表的IS锁。

使用行锁会引入下面四个问题：

- 更新丢失：让事务变成串行操作，而不是并发操作，在每一个事务开始时对读取记录加排他锁。

- 脏读：使用MVCC机制来避免

- 不可重复读：使用MVCC机制或Next-Key-Lock算法来避免

- 幻读：使用间隙锁(Gap Lock)

特点：对一行数据加锁，开销大，加锁慢，会出现死锁，锁粒度小，锁冲突概率低，并发性高。

### 页锁

开销，加锁时间和锁粒度介于表锁和行锁之间，会出现死锁，并发处理能力一般。

## 锁相关操作

### 表锁

- 隐式上锁(自动加锁自动释放)：select(读锁)，insert,update,delete(写锁)

- 显式上锁(手动)：lock table tableName read;(读锁)，lock table tableName;(写锁)。

- 解锁(手动)：unlock table tableName;(单表)，unlock tables;(所有表)。

- 查看表锁情况：show open tables;

- 表锁分析：show status like 'table%'

  - table_locks_waited：出现表锁争用而发生等待的次数

  - table_locks_immediate：产生表级锁定次数 

### 行锁

- 隐式上锁(自动加锁自动释放)：select(不会自动加锁)，insert,update,delete(自动加排他锁)。

- 显式上锁(手动)：select * from user lock in share mode(共享锁)，select * from user for update(排他锁)。 

- 解锁(手动)：提价事务(commit)，回滚事务(rollback)，kill阻塞进程。

- 查看行锁情况：show status like '%innodb_row_lock%';

  - innodb_row_lock_current_waits：当前正在等待锁定的数量

  - innodb_row_lock_time：从系统启动到现在锁定总时间长度

  - innodb_row_lock_time_avg：每次等待所花平均时间

  - innodb_row_lock_time_max：从系统启动到现在等待花费最长的一次所花费时间

  - innodb_row_lock_waits：系统启动到现在总共等待次数。

  - infomation_schema库中innodb_lock_waits表，innodb_locks表，innodb_trx表。

行锁优化建议：

- 尽可能让所有数据检索都通过索引完成，避免无索引行锁升级为表锁。

- 合理设计索引，尽量缩小锁的范围。

- 尽可能减少检索条件，避免间隙锁。

- 尽可能控制事务大小，减少锁定资源量和时间长度。

- 尽可能低级别事务隔离。

## 乐观锁与悲观锁

悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。表锁，行锁都是悲观锁，适用于并发量比较大的场景。数据库系统中常用。

乐观锁：假设不会发生并发冲突，只有在提交时检查是否违反数据完整性，比如提交时通过检查版本号或者时间戳是否符合，适用于并发量比较小的场景。业务代码中常用。

## 死锁

死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。

查看死锁：show engine innodb status;\G

自动检测机制会在超时后自动回滚代价小的事务(innodb_lock_wait_timeout默认50s)

### 产生的条件

- 互斥条件：一个资源每次只能被一个事务使用。

- 请求和保持条件：一个事务因请求资源而阻塞时，对方已获得的资源保持不放。

- 不剥夺条件：进程已经获得的资源，在没有使用完之前不能被强行剥夺。

- 循环等待条件：多个事务之间形成一种相互循环等待资源的关系。

### 如何避免死锁

- 加锁顺序一致，尽可能一次性锁定所需的数据行。

- 尽量基于主键或者唯一键更新数据。

- 单次操作数据量不宜过多，涉及的表尽量少。

- 减少表上索引，减少锁定资源。

- 尽量使用较低的隔离级别。

- 尽量使用相同条件访问数据，避免间隙锁对并发的插入影响。

- 精心设计索引，尽量使用索引访问数据。

- 借助相关工具分析，pt-deadlock-logger。

