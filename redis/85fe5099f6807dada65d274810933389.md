# 集群

在哨兵模式中如果主从中 master宕机了，是通过哨兵来选举出新的master，在这个选举切换主从的过程，整个redis服务是不可用的。

哨兵模式中只有一个主节点对外提供服务，因此没法支持更高的并发。

当个主节点的内存设置也不宜过大。否则会导致持久化文件过大，影响数据恢复或主从同步的效率。

## Redis集群工作原理

redis集群是由 一系列的 主从节点群组成的分布式服务器群，它具有复制、高可用和分片特性。 Redis集群不需要 sentinel哨兵也能完成节点移除和故障转移的功能。需要将每个节点设置成集群模式，这种集群模式没有中心节点。

客户端通过 CRC16算法对key进行hash得到一个值，来判断该 key存储在哪个主从服务上面，因此就算是某一个主从整个宕机，redis集群也是部分可用的。方便水平扩展，可以根据业务规模可以随时加减配置。据官方文档称可以线性扩展到上万个节点 ( 但是 官方推荐不超过 1000个节点)。

redis集群的性能和高可用性均优于哨兵模式 。

当 Redis Cluster 的客户端来连接集群时，它也会得到一份集群的槽位配置信息并将其缓存在客户端本地。这样当客户 端要查找某个 key 时，可以直接定位到目标节点。同时因为槽位的信息可能会存在客户端与服务器不一致的情况，还需 要纠正机制来实现槽位信息的校验调整。

## 集群选举机制

当slave发现自己的master变为FAIL状态时，便尝试发起选举，以期成为新的master。由于挂掉的master可能会有多个slave，从而存在多个slave竞争成为master节点的过程，其过程如下：

1. slave发现自己的master变为FAIL

2. 将自己记录的集群currentEpoch(选举轮次标记)加1，并广播信息给集群中其他节点

3. 其他节点收到该信息，只有master响应，判断请求者的合法性，并发送结果

4. 尝试选举的slave收集master返回的结果，收到 超过半数 master的统一 后变成新 Master

5. 广播Pong消息通知其他集群节点。

如果这次选举不成功就会发起第二次选举，选举轮次标记+1继续上面的流程。事实上从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待FAIL状态在集群中传播，

slave如果立即尝试选举，其它masters或许尚未意识到FAIL状态，可能会拒绝投票。 同时下面公式里面的随机数，也可以有效避免slave同时发起选举，导致的平票情况。

延迟计算公式：DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms

>SLAVE_RANK表示此slave已经从master复制数据的总量的rank。Rank越小代表已复制的数据越新。这种方式下，持有最新数据的slave将会首先发起选举(理论上)。

前面说到这种分片的集群模式的集群可以部分提供服务，当 redis.conf的配置cluster-require-full-coverage为no时，表示当一个小主从整体挂掉的时候集群也可以用，也是说 0-16383个槽位中，落在该主从对应的slots上面的key是用不了的，但是如果key落在其他的范围是仍然可用的。

## gossip协议

Redis 节点之间使用的是gossip协议进行通信，每个节点之间都会互相通信。gossip协议包含多种消息，包括 ping，pong，meet，fail等等。

gossip 协议的优点在于元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新， 有一定的延时，降低了压力;缺点在于元数据更新有延时可能导致集群的一些操作会有一些滞后






