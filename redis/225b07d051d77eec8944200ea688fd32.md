# Redis的两种持久化机制

从数据重用和故障恢复两个角度出发，redis提供了持久化功能，即将内存中的数据同步到磁盘中。Redis提供了两种不同的持久化方法，一种是快照的方式RDB，另一种是追加文件的方式AOF。

## RDB

- RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中。

- RDB持久化功能生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态。

- RDB由Redis启动时自动检测并载入。

有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE。

- SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完成为止，在服务器进程阻塞期间，服务器不能处理任何命令请求

- BGSAVE命令会fork出一个子进程，然后由子进程来负责创建RDB文件，服务器进程(父进程)继续处理命令请求。

### 如何触发RDB持久化

- 配置文件中快照配置：通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。用户可以通过save选项设置多个保存条件，只要其中任意一个条件满足，服务器就会执行BGSAVE命令。默认条件如下：

   ```
   save 900 1          # 服务器在900秒之内，对数据库进行了至少1次修改
   save 300 10         # 服务器在300秒之内，对数据库进行了至少10次修改
   save 60 10000       # 服务器在60秒之内，对数据库进行了至少10000次修改
   ```

- 执行命令save或者bgsave

- 执行flushall命令，也会生成dump.db文件

### 如何恢复

将备份文件dump.db移动到redis安装目录并启动服务即可

### 如何停止

动态所有停止RDB保存规则的方法：redis-cli config set save " "

### 优缺点

- 由于RDB是二进制文件，并且支持压缩，RDB文件体积小，恢复速度快，如果要备份数据量大RDB方式要比AOF方式更加高效。

- RDB的缺点是最后一次持久化后的数据可能丢失。

![](../assets/225b07d051d77eec8944200ea688fd32_1.png)

## AOF

- 被写入AOF文件的所有命令都是以Redis命令请求协议格式保存的，Redis命令请求协议是纯文本格式，因此AOF文件是文本文件，可以直接打开。

- 服务器在启动时，可以通过载入和执行AOF文件中保存的命令来还原服务器关闭之前的数据库状态

### 持久化过程

- 命令追加：当AOF持久化功能处于打开状态时，服务器在执行完一个命令后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区末尾。

- 文件写入：服务器每次结束一个事件循环之前，都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件中。

- 文件同步：同步行为由服务器配置的appendfsync选项值来决定

  - always：每个事件循环将aof_buf缓冲区的所有内容写入并同步到AOF文件。从效率上讲是三者中最慢的，从安全性上讲是最安全的。出现故障停机，会丢失一个事件循环中产生的命令。

  - everysec：每个事件循环将aof_buf缓冲区的所有内容写入到AOF文件，如果上次同步AOF文件的时间距离现在超过1秒钟，那么再次对AOF文件进行同步，并且这个同步操作是由一个线程专门负责执行的。从效率上讲足够快，出现故障停机，会丢失一秒钟的数据。

  - no：每个事件循环将aof_buf缓冲区中的所有内容写入到AOF文件，但并不对AOF文件进行同步，何时同步由操作系统来决定。写入速度是最快的，出现故障停机时，会丢失上次同步AOF命令的所有写命令

同步间隔设置粒度越细，性能越差，数据丢失风险越低。默认值为everysec。

### AOF重写过程

AOF重写是通过读取当前数据库状态来实现的，而非读取原来的AOF文件。从数据库读取键现在值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令。

- 创建新的AOF文件。

- 遍历数据库，忽略空的数据库。

- 遍历数据库中的所有键，忽略过期键

- 根据键的类型进行语句重写

- 如果有过期时间则设置过期时间

### AOF后台重写

Redis的BGREWRITEAOF命令将AOF重写程序放到子进程中执行，这样做有两点好处：

- 子进程在AOF重写期间，服务器进程(父进程)可以继续处理命令请求。

- 子进程带有父进程数据的副本，使用子进程而不是线程，可以避免锁的竞争，同时保证数据安全。

子进程在进行AOF重写期间，服务器还要继续处理命令请求，新的命令会对数据库状态进行修改，从而使当前数据库状态和重写后的AOF文件保存的数据库状态不一致。

为了解决这种不一致的问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。

- AOF缓冲区的内容会定期被写入和同步到AOF文件中，对现有AOF文件处理工作会正常进行。

- 从创建子进程开始，服务器执行的所有写命令都会被记录到AOF重写缓冲区里面。

当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程收到该信号后，调用一个信号处理函数，并执行以下工作：

- 将AOF重写缓冲区中所有内容写入到新的AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。

- 对新的AOF文件进行改名，原子的覆盖现有AOF文件，完成新旧两个AOF文件替换。

这个信号处理完成后，父进程可以继续像往常一样接受命令请求了。

### 优缺点

- AOF文件保存的数据集比RDB文件保存的数据集完整性好。

- 相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb

![](../assets/225b07d051d77eec8944200ea688fd32_2.png)

如果同时开启两种持久化方式，当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。

## 最佳实践

因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。
  
如果Enalbe AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价一是带来了持续的IO，二是AOFrewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。

只要硬盘许可，应该尽量减少AOF重写的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。
 
如果不Enable AOF，仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个,新浪微博就选用了这种架构。
