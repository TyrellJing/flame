# 单链表实现

使用Golang实现一个单链表，功能包括获取链表长度，头节点，尾节点，插入节点和删除节点。

```golang
package slist

type sNode struct {
    Value   interface{}
    next    *sNode
}

func (sn *sNode) Next() *sNode {
    if sn != nil {
        return sn.next
    }
    return nil
}

type sList struct {
    head    *sNode
    len     int
}

func NewSingleList() *sList {
    return &sList{}
}

func (sl *sList) Len() int {
    return sl.len
}

func (sl *sList) Front() *sNode {
    return sl.head
}

func (sl *sList) Back() *sNode {
    p := sl.head
    for p.next != nil {
        p = p.next
    } 
    return p
}

func (sl *sList) PushFront(node *sNode) *sNode {
    node.next = sl.head
    sl.head = node
    sl.len++
    return node
}

func (sl *sList) PushBack(node *sNode) *sNode {
    tail := sl.Back()
    tail.next = node
    sl.len++
    return node
}

func (sl *sList) InsertBefore(node, before *sNode) *sNode {
    p := sl.head
    for p != nil && p.next != before {
        p = p.next
    }
    return sl.insert(node, p)
}

func (sk *sList) InsertAfter(node, after *sNode) *sNode {
    return sl.insert(node, after)
}

func (sl *sList) insert(node, at *sNode) *sNode {
    next := at.next
    at.next = node 
    node.next = next
    sl.len++
    return node
}

func (sl *sList) insertVal(val interface{}, at *sNode) *sNode {
    node := new(sNode)
    node.Value = val
    return sl.insert(node, at)    
}

func (sl *sList) Remove(node *sNode) interface{} {
    if sl.len == 0 || node == nil {
        return nil
    }
    if node == sl.head {
        p := sl.head
        sl.head = sl.head.next
        sl.len--
        return p.Value
    }
    p := sl.head
    for p != nil && p.next != node {
        p = p.next
    } 
    if p == nil {
        return nil
    }
    p.next = p.next.next
    sl.len--
    return node.Value
}

```